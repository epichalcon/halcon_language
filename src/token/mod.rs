use core::fmt::Display;

use strum_macros::EnumString;

#[derive(EnumString, Clone, Debug, PartialEq, Hash, Eq)]
pub enum Token {
    Id(String),
    ConstInt(String),
    ConstFloat(String),
    ConstStr(String),
    ConstBool(String),

    Int,
    Str,
    Bool,
    Float,
    Arr,

    Plus,
    Minus,
    Mult,
    Div,
    Mod,

    Eq,
    Neq,
    Lt,
    Gt,
    Le,
    Ge,

    And,
    Or,
    Not,

    Inc,
    Dec,

    Assig,
    SumAsig,
    MinAsig,
    MulAsig,
    DivAsig,

    Fun,
    Let,
    Arrow,
    Return,
    Raw,
    Begin,
    If,
    Elif,
    Else,
    For,
    Loop,
    While,

    Input,
    Print,

    Coma,
    Semicolon,
    Colon,

    Opar,
    Cpar,
    Obrac,
    Cbrac,
    Okey,
    Ckey,

    Eof,
    Invalid(String),
}

impl Display for Token {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Token::Id(x) => write!(f, "Id({})", x),
            Token::ConstInt(x) => write!(f, "ConstInt({})", x),
            Token::ConstFloat(x) => write!(f, "ConstFloat({})", x),
            Token::ConstStr(x) => write!(f, "ConstStr({})", x),
            Token::ConstBool(x) => write!(f, "ConstBool({})", x),
            Token::Invalid(x) => write!(f, "Invalid({})", x),
            Token::Int => write!(f, "Int"),
            Token::Str => write!(f, "Str"),
            Token::Bool => write!(f, "Bool"),
            Token::Float => write!(f, "Float"),
            Token::Arr => write!(f, "Arr"),
            Token::Plus => write!(f, "Plus"),
            Token::Minus => write!(f, "Minus"),
            Token::Mult => write!(f, "Mult"),
            Token::Div => write!(f, "Div"),
            Token::Mod => write!(f, "Mod"),
            Token::Eq => write!(f, "Eq"),
            Token::Neq => write!(f, "Neq"),
            Token::Lt => write!(f, "Lt"),
            Token::Gt => write!(f, "Gt"),
            Token::Le => write!(f, "Le"),
            Token::Ge => write!(f, "Ge"),
            Token::And => write!(f, "And"),
            Token::Or => write!(f, "Or"),
            Token::Not => write!(f, "Not"),
            Token::Inc => write!(f, "Inc"),
            Token::Dec => write!(f, "Dec"),
            Token::Assig => write!(f, "Assig"),
            Token::SumAsig => write!(f, "SumAsig"),
            Token::MinAsig => write!(f, "MinAsig"),
            Token::MulAsig => write!(f, "MulAsig"),
            Token::DivAsig => write!(f, "DivAsig"),
            Token::Fun => write!(f, "Fun"),
            Token::Let => write!(f, "Let"),
            Token::Arrow => write!(f, "Arrow"),
            Token::Return => write!(f, "Return"),
            Token::Raw => write!(f, "Raw"),
            Token::Begin => write!(f, "Begin"),
            Token::If => write!(f, "If"),
            Token::Elif => write!(f, "Elif"),
            Token::Else => write!(f, "Else"),
            Token::For => write!(f, "For"),
            Token::Loop => write!(f, "Loop"),
            Token::While => write!(f, "While"),
            Token::Input => write!(f, "Input"),
            Token::Print => write!(f, "Print"),
            Token::Coma => write!(f, "Coma"),
            Token::Semicolon => write!(f, "Semicolon"),
            Token::Colon => write!(f, "Colon"),
            Token::Opar => write!(f, "Opar"),
            Token::Cpar => write!(f, "Cpar"),
            Token::Obrac => write!(f, "Obrac"),
            Token::Cbrac => write!(f, "Cbrac"),
            Token::Okey => write!(f, "Okey"),
            Token::Ckey => write!(f, "Ckey"),
            Token::Eof => write!(f, "Eof"),
        }
    }
}
